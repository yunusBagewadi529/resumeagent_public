package com.resumeagent.service;

import com.resumeagent.config.JwtProperties;
import com.resumeagent.entity.RefreshToken;
import com.resumeagent.entity.User;
import com.resumeagent.repository.RefreshTokenRepository;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.digest.DigestUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.Optional;

/**
 * Service for managing refresh token lifecycle
 * SECURITY ARCHITECTURE:
 * - All refresh tokens are hashed using SHA-256 before storage
 * - Single-use tokens (deleted/revoked after use)
 * - Token rotation on every refresh
 * - Reuse detection triggers security response
 * THREAT MITIGATION:
 * - Database Breach: Hashed tokens cannot be used directly
 * - Token Replay: Single-use enforcement
 * - Session Hijacking: Reuse detection alerts user
 * - Long-term Compromise: Regular token rotation limits blast radius
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RefreshTokenService {

    private final RefreshTokenRepository refreshTokenRepository;
    private final JwtProperties jwtProperties;

    /**
     * Create and store hashed refresh token
     * WHY HASH TOKENS?
     * Same reason we hash passwords:
     * - If database is compromised, attacker cannot use tokens
     * - Defense in depth: database breach â‰  session hijacking
     * - Compliance with security best practices
     * TOKEN LIFECYCLE:
     * 1. Raw token generated by JwtTokenProvider (JWT format)
     * 2. Raw token sent to client via HttpOnly cookie
     * 3. Raw token hashed with SHA-256
     * 4. Hash stored in database
     * 5. Raw token never stored
     *
     * @param user     User entity
     * @param rawToken JWT refresh token (before hashing)
     * @param request  HTTP request for context (IP, user agent)
     */
    @Transactional
    public void createRefreshToken(User user, String rawToken, HttpServletRequest request) {
        // Hash the token before storage (SHA-256 is used for token hashing; no BCrypt)
        String tokenHash = DigestUtils.sha256Hex(rawToken);

        // Calculate expiration
        Instant expiration = Instant.now().plusMillis(jwtProperties.getRefreshTokenExpirationMs());

        // Create token entity with security context
        RefreshToken refreshToken = RefreshToken.builder()
                .user(user)
                .tokenHash(tokenHash)
                .expiresAt(expiration)
                .revoked(false)
                .ipAddress(extractClientIp(request))
                .userAgent(request.getHeader("User-Agent"))
                .build();

        RefreshToken saved = refreshTokenRepository.save(refreshToken);
        log.info("Created refresh token for user: {} from IP: {}", user.getEmail(), saved.getIpAddress());

    }

    /**
     * Validate refresh token (hash matching)
     * VALIDATION PROCESS:
     * 1. Hash incoming raw token (SHA-256)
     * 2. Query database for matching hash
     * 3. Check expiration
     * 4. Check revoked status
     * SECURITY NOTE:
     * Uses SHA-256 hashing (fast, no 72-byte limit)
     * This method compares the deterministic hash of the raw token
     * with stored token hashes in the database.
     *
     * @param rawToken Raw refresh token from cookie
     * @return Optional containing valid token if found
     */
    @Transactional(readOnly = true)
    public Optional<RefreshToken> validateRefreshToken(String rawToken) {
        // Compute SHA-256 of incoming token
        String incomingHash = DigestUtils.sha256Hex(rawToken);

        // Query all tokens to check hash match
        // NOTE: For security we still perform application-layer checks; the repository
        // could expose a finder by tokenHash for efficiency if desired.
        return refreshTokenRepository.findAll().stream()
                .filter(token -> incomingHash.equals(token.getTokenHash()))
                .filter(token -> !token.isExpired())
                .filter(token -> !token.isRevoked())
                .findFirst();
    }

    /**
     * Mark refresh token as used
     * Updates lastUsedAt timestamp for audit trail
     *
     * @param refreshToken Token to mark as used
     */
    @Transactional
    public void markTokenUsed(RefreshToken refreshToken) {
        refreshToken.markUsed();
        refreshTokenRepository.save(refreshToken);
    }

    /**
     * Revoke refresh token (single token)
     * Sets revoked flag and timestamp
     * Token remains in database for audit trail
     * Used for:
     * - Logout (individual session)
     * - Security incident (specific token compromised)
     *
     * @param refreshToken Token to revoke
     */
    @Transactional
    public void revokeToken(RefreshToken refreshToken) {
        refreshToken.revoke();
        refreshTokenRepository.save(refreshToken);
        log.info("Revoked refresh token for user: {}", refreshToken.getUser().getEmail());
    }

    /**
     * Delete refresh token (immediate removal)
     * Permanently deletes token from database
     * Use when token is consumed during rotation
     *
     * @param refreshToken Token to delete
     */
    @Transactional
    public void deleteToken(RefreshToken refreshToken) {
        refreshTokenRepository.delete(refreshToken);
        log.debug("Deleted refresh token for user: {}", refreshToken.getUser().getEmail());
    }

    /**
     * Revoke all user tokens (security response)
     * WHEN TO USE:
     * - Token reuse detected (potential hijacking)
     * - User reports suspicious activity
     * - Admin forces re-authentication
     * - Account security settings changed (password reset, etc.)
     * SECURITY IMPACT:
     * All active sessions terminated
     * User must re-authenticate on all devices
     *
     * @param user User whose tokens should be revoked
     */
    @Transactional
    public void revokeAllUserTokens(User user) {
        refreshTokenRepository.deleteByUser(user);
        log.warn("Revoked ALL refresh tokens for user: {} (security response)", user.getEmail());
    }

    /**
     * Cleanup expired tokens (scheduled maintenance)
     * Should be called by scheduled job (e.g., daily at 2 AM)
     * Prevents database bloat from old tokens
     *
     * @return Number of deleted tokens
     */
    @Transactional
    public int cleanupExpiredTokens() {
        int deleted = refreshTokenRepository.deleteExpiredTokens(Instant.now());
        if (deleted > 0) {
            log.info("Cleaned up {} expired refresh tokens", deleted);
        }
        return deleted;
    }

    /**
     * Count active tokens for user
     * Used for:
     * - Session management UI (show active devices)
     * - Security monitoring (detect unusual patterns)
     * - Rate limiting (prevent too many concurrent sessions)
     *
     * @param user User entity
     * @return Number of active refresh tokens
     */
    @Transactional(readOnly = true)
    public long countActiveTokens(User user) {
        return refreshTokenRepository.countActiveTokensByUser(user, Instant.now());
    }

    /**
     * Extract client IP address from request
     * SECURITY CONTEXT:
     * IP address is logged for:
     * - Audit trail
     * - Anomaly detection (login from new location)
     * - Security incident investigation
     * Checks X-Forwarded-For header for proxy/load balancer scenarios
     *
     * @param request HTTP request
     * @return Client IP address
     */
    private String extractClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            // X-Forwarded-For can contain multiple IPs, first is client
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }
}
